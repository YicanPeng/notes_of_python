# -*- coding: utf-8 -*-
""" 程序 = 数据结构 + 算法,数据结构分3种:排序,判断(选择),循环 """
""" 递归算法本质是数学归纳法,函数在内部调用自身,即计算第N项与第N-1项的关系,而后一直倒推到第1项,也就是基例
   运用的数据结构其实是栈stack,先堆栈push后弹出pop """
""" 1.基础语法,注释 """
""" 除关键字外,python变量赋值就是声明变量,字典列表集合赋值为空,就是元素不定的变量 """
""" 交叉赋值,同时赋值是python特色,使得本来需要中间过渡变量的交叉赋值,同时完成 """
""" 引用模块时添加别名,简化语句 """
# import keyword as k
""" python的保留字无法重命名,也无法命名其他关键字,特别注意True,False,None是大写开头 """
# print(k.kwlist)
""" python对缩进敏感,冒号表示开始子句,缩进表示子句所处的层次 """
# if True:
#     print("yes")
# else:
#     print('no')
""" python语句换行使用反斜杠 """
""" 反斜杠也是文本字符转义符"""
""" 文本引号前加r或R表示raw,反转义,使转义符和文本标点符(如换行符)无效 """
""" 三引号字符串所见即所得 """
""" python空行只是为了区分函数块,无实际意义 """
""" 同一行内多条语句时,python使用;分号表示语句结束(不推荐一行多条语句) """
""" print输出默认换行,可以在结尾加上end=连接符,连接不同print字符串 """
str000="runoob"
# print(str,"\n")
# print(r"\n")
# print("a",end="傻逼")
# print("随便")
# print(""" \n """)

""" 数据类型 """
""" python有6种数据类型:数字number,字符串string,元组tuple,列表list,字典dictionary,集合set;
   其中数字,字符串,元组是不可变数据类型
   例如以下三个变量无法再修改数字,字符串和元组的元素,只能对变量重新赋值 """
""" 字符串string,列表list,元组tuple都属于序列,都可以用索引数字进行截取和索引,索引从0计数
   [头标:尾标[:步长]],步长为可选参数,默认为1,负值为逆向查找,索引区间为前闭后开区间,
   如需索引到最后一位,则尾标留空
   索引可以连续索引,如tup001[1][0] """
""" 列表和元组是迭代器,用于循环遍历 """
num001=1234;str001="runoob";tup001=(num001,str001,0)
# num001[0]=5
# str001[0]="x"
# tup001[0]="a"
# print(tup001[1][0])
""" type函数可以返回值的类,isinstance函数判断是否属于指定的类,
   而且isinstance认为子类是父类的一种,而type不认为子类是父类的一种 """
"""使用del 变量1,变量2...  可以删除对象"""
""" 数字包括整数,浮点数,布尔值,复数;复数的虚部关键字j """
""" 列表标识符是中括号[] """
""" 元组标识符是小括号(),空元祖()内无需元素,一个元素的元组需要在元素后加逗号,如tup002_1,否则小括号会被识别为运算符号 """
str002="runoob";lis002=["a",1,3+2j];tup002=(str002,lis002,0);tup002_1=("a",);str002_1=("a")
# print(str002[0::2]);print(lis002[1:-1]);print(tup002[1]),print(tup002_1);print(type(str002_1))
# print("\a")





""" 集合set和字典dictionary的标识符都是大括号{},其中空集合只能用set()赋值,而{}赋值的是空字典 """
""" 集合使用用set函数赋值,则值必须是可迭代的,即必须是字符串或列表或元组,且只能是一个值或空值
   以下set003_1和set003_2就无法赋值 """
""" 集合的元素是无序的,因此无法索引 """
""" 集合输出时,重复元素会被自动剔除 """
""" 集合常用于判断元素关系和删除重复元素 """
set003=set("123321")
set003_3=set("1214")
# set003_1=set(123)
# set003_2=set("1","2","3")
# print(set003)
""" 集合可以进行运算 """
""" 集合的差集,003集合存在而003_3不存在的元素 """
# print(set003 - set003_3)
""" 集合的并集 """
# print(set003 | set003_3)
""" 集合的交集 """
# print(set003 & set003_3)
""" 集合中不同时存在的元素 """
# print(set003 ^ set003_3)
# print(set003[0])
""" 字典的元素是由(键:值)成对组成的元素;字典也使用中括号[]索引,但不使用下标索引,使用键索引;
   键必须是唯一的,而且必须是不可变数据类型(数字或字符串或元组) """
""" 字典常用以下几种方式赋值 """
""" 例1空字典添加 """
dic004_1={}
dic004_1["one"]=1
dic004_1[2]="second"
# print(dic004_1)
""" 例2循环语句赋值 """
dic004_3={x:x**3 for x in range(1,3,1)}
# print(dic004_3)
""" dict函数的参数可以是成对赋值如例3,参数可以是列表如例4和例5 """
""" 例3dict函数成对赋值,这种声明方式,键必须是字符串或元组(因为数字无法被赋值) """
dic004_4 = dict(runoob=1,Google =2,淘宝=3)
# print(dic004_4)
""" 例4dict函数用成对元组作为元素的列表赋值 """
dic004_2=dict([("雅蠛蝶",233),("stupid",1)])
# print(dic004_2["雅蠛蝶"])
""" 例5dict函数和zip函数嵌套赋值 """
lis004_5_1=[1,2,3]
lis004_5_2=["谷歌","淘宝","企鹅","alibaba"]
lis004_5_3=zip(lis004_5_1,lis004_5_2)
dic004_5=dict(lis004_5_3)
# print(lis004_5_3)
# print(dic004_5)
""" zip函数用于把两个列表配对成成对元组作为元素的一维列表,其反用法如下 """
lis004_a,lis004_b = zip(*zip(lis004_5_1,lis004_5_2))
# print(lis004_a,lis004_b)



""" 内置函数和自定义函数 """
""" 不可变对象相当于VBA的值传递,原有变量不会被函数运算重新赋值;
   可变对象类似引用传递,与函数共享同一内存指针,会在函数运算后被重新赋值 """
""" 函数没有return,返回值是None """
""" 自定义函数时,可以声明缺省参数,如本例中的l参数和n参数
   加*的参数是不定长参数,类似VBA的可选参数,加一个*,返回值是元组类型,如本例m参数;
      加两个*,返回值是字典类型
   在引用函数时,不定长参数之后的参数必须使用索引名赋值,如本例n参数 """
def fibo(l=100,*m,n=100):
   a,b=0,1
   list_fibo=[b]
   n = int(n)
   while b<n+l:
      list_fibo.append(b)
      a,b=b,a+b 
   print(m)
   return list_fibo
""" 交叉赋值,同时赋值是python特色之一 """
""" 本例中第3参数必须使用索引名赋值 """
print(fibo(100,n=1))
""" map函数两个参数,第一个是内嵌函数,第二个是内嵌函数所有参数的序列,map函数会遍历序列,分别代入
   (内嵌函数参数不能空,但可以是None,以最短参数序列为准),
   并按第一个原序列的数据类型和返回值生成一个map对象(不是序列,需要使用格式转换函数变成序列) """
# print(tuple(map(fibo,[100,200,300],(None,),(None,None))))
# print(tuple(map(fibo,[100,200,300],(None,None),(None,None)))[0][0])
""" 模块 """
""" 只有包含__init__.py模块的文件夹才会被python认定为包,以免识别其他文件 """
""" 包和模块有两种引入方式,即:import 模块 和 from 模块 import 函数 ;
其中import 函数名 from 模块 可以直接调用函数名,无需 包名.模块.函数 的方式调用函数
但是后引入的函数会覆盖之前引入的同名函数,因此不推荐此方法引入函数"""
import sys
""" 引入函数以后,可以通过赋值的方式(函数无需加参数括号),对函数进行重命名,以减小代码量 """
""" sys.path属性返回python引入包和模块的所有路径,第一个路径永远是当前py文件所在的文件夹
可以通过sys.path.append(模块路径)的方式手动添加模块路径 """
aaa = sys.path
bbb = fibo
# print(aaa)
""" dir函数返回包或模块或函数所有自定义的关键字 """
# print(dir(bbb))
# bbb()
""" 文件引用自身内置属性和方法,无需前缀,__name__属性永远是__main__ """
# print(__name__)





























""" 注释不要打断缩进关系树,如本例中从class下穿和def连接def的纵线 """
class Vector:
   """ 自定义类的方法第一个参数是方法的实例自身,例命名为self,也可以随意命名,但不推荐 """
   """ 自定义类有若干内置的私有方法和属性,即使没有声明也可以内部调用,包括init,class,name,main """
   def __init__(self, a, b):
      self.a = a
      self.b = b
   def __str__(self):
      return 'Vector (%d, %d)' % (self.a, self.b)
   """ 注释只能与代码块主句对齐,不能与子句缩进 """
   """ 运算符重载也是内置的私有方法,使得类可以按照自定义的方法使用各类基础运算符
   本例为使用加号运算符 """
   def __add__(self,other):
      return Vector(self.a + other.a, self.b + other.b)
   """ self参数代表的是类的实例(也即是变量),而非类本身 """
   def prt(self):
      print(self)
      print(self.__class__)
      print(self.__str__.__doc__)
""" 自定义类的第一个参数必须是实例本身,即使是无参方法,也必须声明实例本身作为参数 """
""" 自定义类从第二个参数开始,才是真正的参数 """
v1 = Vector(2,10)
v2 = Vector(5,-2)
v3 = Vector(1,2)
# print(v1+v2+v3)
# print(v1)
""" 类的私有属性和方法以双下划线开头,私有属性无法被实例从外部调用,但是类的私有属性可以被外部调用 """
# print(v1.__class__.__name__)
# v1.prt()

""" print可以输出两个文本,其中sep参数是两个文本的间隔符,默认为空格,end参数是两个print之间的连接符,默认为回车 """
# print(1,2,sep=",",end=".")
# print("a")
""" help函数是内置函数,返回数据类型或函数或模块的详细说明 """
# help(print)